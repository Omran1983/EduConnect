name: EduConnect Events to Supabase

on:
  push:
    branches: ["main", "master"]
  pull_request:
    types: [opened, synchronize, reopened, closed]
  release:
    types: [published]
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: read

jobs:
  log:
    runs-on: ubuntu-latest
    steps:
      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Build JSON payload
        run: |
          set -e
          KIND="$GITHUB_EVENT_NAME"
          REPO="$GITHUB_REPOSITORY"
          ACTOR="$GITHUB_ACTOR"
          SERVER="$GITHUB_SERVER_URL"
          RUN_ID="$GITHUB_RUN_ID"
          SHA="$GITHUB_SHA"
          REF="$GITHUB_REF"
          SHORT_SHA="${SHA:0:7}"
          RUN_URL="$SERVER/$REPO/actions/runs/$RUN_ID"

          TITLE="Event $KIND @ $REPO"
          META=$(jq -n --arg actor "$ACTOR" --arg run "$RUN_URL" '{actor:$actor, run_url:$run}')

          if [ "$KIND" = "push" ]; then
            BRANCH="${REF#refs/heads/}"
            COMMIT_MSG="$(jq -r '.head_commit.message // "n/a"' "$GITHUB_EVENT_PATH")"
            TITLE="PUSH $SHORT_SHA @ $REPO:$BRANCH"
            META=$(jq -n --arg actor "$ACTOR" --arg msg "$COMMIT_MSG" --arg run "$RUN_URL" --arg sha "$SHA" \
                   '{actor:$actor, message:$msg, run_url:$run, sha:$sha}')
          elif [ "$KIND" = "pull_request" ]; then
            PR_ACTION="$(jq -r '.action' "$GITHUB_EVENT_PATH")"
            PR_TITLE="$(jq -r '.pull_request.title' "$GITHUB_EVENT_PATH")"
            PR_MERGED="$(jq -r '.pull_request.merged // false' "$GITHUB_EVENT_PATH")"
            TITLE="PR ($PR_ACTION): $PR_TITLE"
            META=$(jq -n --arg actor "$ACTOR" --arg action "$PR_ACTION" --arg run "$RUN_URL" --argjson merged "$PR_MERGED" \
                   '{actor:$actor, action:$action, merged:$merged, run_url:$run}')
          elif [ "$KIND" = "release" ]; then
            REL_TAG="$(jq -r '.release.tag_name' "$GITHUB_EVENT_PATH")"
            REL_URL="$(jq -r '.release.html_url' "$GITHUB_EVENT_PATH")"
            TITLE="RELEASE $REL_TAG"
            META=$(jq -n --arg actor "$ACTOR" --arg url "$REL_URL" --arg run "$RUN_URL" \
                   '{actor:$actor, url:$url, run_url:$run}')
          fi

          jq -n --arg source "github" --arg kind "$KIND" --arg title "$TITLE" --argjson meta "$META" \
             '{source:$source, kind:$kind, title:$title, meta:$meta}' > payload.json

          echo "Payload:"
          jq . payload.json

      - name: Supabase sanity probe (GET, list tables)
        env:
          SUPABASE_URL:          ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE: ${{ secrets.SUPABASE_SERVICE_ROLE }}
        run: |
          set -e
          if [ -z "$SUPABASE_URL" ] || [ -z "$SUPABASE_SERVICE_ROLE" ]; then
            echo "::error ::Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE"
            exit 1
          fi
          echo "SUPABASE_URL_OK=$([[ "$SUPABASE_URL" =~ ^https://.+\.supabase\.co$ ]] && echo 1 || echo 0)"
          echo "SERVICE_ROLE_LEN=${#SUPABASE_SERVICE_ROLE}"

          # Probe with a harmless GET on an existing table using service_role auth.
          # This should return 200 (or 206) if the key is valid.
          curl -sS -D headers.txt -o resp_probe.json -w "%{http_code}" \
            -G "$SUPABASE_URL/rest/v1/project_events" \
            -H "apikey: $SUPABASE_SERVICE_ROLE" \
            -H "Authorization: Bearer $SUPABASE_SERVICE_ROLE" \
            --data-urlencode "select=id&limit=1" > status_probe.txt

          echo "PROBE_HTTP_STATUS=$(cat status_probe.txt)"
          echo "PROBE_HEADERS_START"; sed -n '1,120p' headers.txt; echo "PROBE_HEADERS_END"
          echo "PROBE_RESPONSE_START"; cat resp_probe.json; echo "PROBE_RESPONSE_END"

          code=$(cat status_probe.txt)
          # 2xx is OK; 401 means wrong key; 404 means table missing
          if [ "$code" -ge 400 ]; then
            echo "::error ::Probe failed HTTP $code (401=bad key; 404=table missing)"
            exit 1
          fi

      - name: Insert into Supabase (diagnostic)
        env:
          SUPABASE_URL:          ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE: ${{ secrets.SUPABASE_SERVICE_ROLE }}
        run: |
          set -e
          curl -sS -D headers_ins.txt -o resp_ins.json -w "%{http_code}" \
            -X POST "$SUPABASE_URL/rest/v1/project_events" \
            -H "apikey: $SUPABASE_SERVICE_ROLE" \
            -H "Authorization: Bearer $SUPABASE_SERVICE_ROLE" \
            -H "Content-Type: application/json" \
            -H "Prefer: return=representation" \
            -H "Accept-Profile: public" \
            -H "Content-Profile: public" \
            --data-binary @payload.json > status_ins.txt

          echo "HTTP_STATUS=$(cat status_ins.txt)"
          echo "HEADERS_START"; sed -n '1,200p' headers_ins.txt; echo "HEADERS_END"
          echo "RESPONSE_START"; (jq . resp_ins.json || cat resp_ins.json); echo "RESPONSE_END"

          code=$(cat status_ins.txt)
          if [ "$code" -ge 400 ]; then
            echo "::error ::Supabase returned HTTP $code"
            exit 1
          fi
